<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wineki Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Wineki Blog">
<meta property="og:url" content="http://imwineki.cn/index.html">
<meta property="og:site_name" content="Wineki Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wineki Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Wineki Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://p3.qhimg.com/d/inn/5bb54637/logo.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://p7.qhimg.com/d/inn/c0099c2d/Wineki.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Wineki</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://www.github.com/Wineki" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HTTP-web传输/" style="font-size: 10px;">HTTP web传输</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">联系我：wuning_aiali@163.com</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Wineki</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://p7.qhimg.com/d/inn/c0099c2d/Wineki.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Wineki</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://www.github.com/Wineki" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-基于canvas统计图实现" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/19/基于canvas统计图实现/" class="article-date">
  	<time datetime="2016-04-19T15:01:29.000Z" itemprop="datePublished">2016-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/基于canvas统计图实现/">基于canvas统计图实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这段时间一直在做人口统计折线图的需求，终于成功的上线了，打算把技术点总结一下，分享粗来。<br>    首先来看看这个磨人的小妖精长成什么样子，<a href="https://www.so.com/s?ie=utf-8&shb=1&src=360sou_newhome&q=%E4%BA%BA%E5%8F%A3" target="_blank">pc端的样纸</a>，<a href="http://m.so.com/s?q=%E4%BA%BA%E5%8F%A3&src=msearch_test&srcg=home_next" target="_blank">移动端的样纸</a>。pc和移动是两种不同的交互模式，绘制的过程中也有一些细节不太一样，在下面的介绍中会有提到，你要坚持读下去哦，来，我们再来张截图留个念~<img src="/img/pada.gif" width="30" height="30" style="display: inline-block"><br>    pc:<br>    <img src="/img/chart1.png" alt="" width="400" height="200"><br>    移动：<br>    <img src="/img/chart2.png" alt="" width="400" height="200"><br>恩，炫耀够了，现在开始讲干货。<br>数据是根据数据端的同学爬数据动态统计出来的，我需要做的就是讲这些统计出来的数据画成统计图，展现出来。<br>这里主要介绍一下几点：</p>
<p><li>绘制前对数据的处理</li></p>
<p><li>根据数据绘制折线图的过程</li></p>
<p><li>canvas在retina屏幕下显示效果的兼容</li></p>
<p><li>对IE6等低版本浏览器的兼容</li><br>首先我们来介绍对数据的处理，由于代码是写在php模板中的，所以所有的数据会以smarty变量的方式传到前端模板中，而canvas进行渲染的数据一定要放在js变量中，所以就需要将smarty中的数据放到js变量中。 <br>  </p>
<pre>var data = $.parseJSON('{ %json_encode($result.display)% }');</pre>

<p>解释一下，首先使用PHP函数json_encode对数据进行json编码，然后我们使用jquery中parseJSON方法对编码后的数据进行解码。这里parseJSON传入的参数要求比较高，稍不符合标准就gg了（官方说法：抛出异常）：<br></p>
<p><li>{test: 1} (test 没有使用双引号包裹).</li></p>
<p><li>{‘test’: 1} (‘test’ 用了单引号而不是双引号包裹).</li></p>
<p><li>“{test: 1}” (test 没有使用双引号包裹).</li></p>
<p><li>“{‘test’: 1}” (‘test’ 用了单引号而不是双引号包裹).</li></p>
<p><li>“‘test’” (‘test’ 用单引号代替双引号).</li></p>
<p><li>“.1” (number 必须以数字开头; “0.1” 将是有效的).</li></p>
<p><li>“undefined” (undefined 不能表示一个 JSON 字符串; 然而null,可以).</li></p>
<p><li>“NaN” (NaN 不能表示一个 JSON 字符串; 用Infinity直接表示无限也是不允许的).</li><br>现在数据已经缓存到js中了，接下来就是对数据的处理，数据处理共分为两部分，一部分是对横纵坐标的处理，另一部分是对折线图中的点的坐标的处理。<br>先说对横纵坐标的处理，由于伟大的PM是个处女座的美男子，对于数据处理要求十万分复杂，在若干次的愉快的争论和商讨后，我们决定将纵坐标展示逻辑：第一个坐标和最后一个坐标展示为数据中的最小值-误差值和最大值+误差值，误差值：数据的（最大值-最小值）*0.05再四舍五入，横坐标排布方案：将除前几个数平均分，剩余的所有都堆积在最后一段。是不是没太听明白，没事，我当时也各种懵圈，上个图片你自己算算就明白了。这是横坐标，你计算一项相邻坐标的差，就明白我的意思啦！<br>横坐标：<img src="/img/chart3.png" alt="" width="400" height="200" style="display:inline-block"><br>纵坐标：<img src="/img/chart4.png" alt="" width="100" height="200" style="display:inline-block"><br>来看看代码处理逻辑：</p>
<pre><code><span class="comment">/*Y轴上下误差*/</span>
var errVal = Math.round((yVal[<span class="number">0</span>] - yVal[yVal.length-<span class="number">1</span>]) *<span class="number">0.05</span>);
var minY = yVal[yVal.length-<span class="number">1</span>] - errVal;
minY = minY &gt; <span class="number">0</span> ? minY : yVal[yVal.length-<span class="number">1</span>]*<span class="number">0.95</span>;
var maxY = yVal[<span class="number">0</span>] + errVal;
<span class="keyword">if</span>(data.cpi_year !== undefined){
    <span class="comment">/*根据具体业务逻辑，此种情况下，采用进一法处理数据*/</span>
    var ySpacing = ((maxY - minY)/<span class="number">3</span>).toFixed(<span class="number">1</span>);
}<span class="keyword">else</span>{
    var ySpacing = Math.<span class="built_in">ceil</span>((maxY - minY)/<span class="number">3</span>);
}
</code></pre><p><br><br>当然实际的业务逻辑比现在说的还会复杂一些，这里就不一一介绍了，我们来看看生成横纵坐标的方法：<br><br></p>
<pre><code><span class="comment">/*生成坐标轴*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">creatCoordinate</span>(<span class="params">param,isX</span>)</span>{
    <span class="keyword">var</span> _this = <span class="keyword">this</span>;
    <span class="keyword">var</span> Carr = <span class="keyword">new</span> <span class="built_in">Array</span>();
    <span class="keyword">if</span>(isX){
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){
            $(param.parentNode,chart).append(<span class="string">'&lt;span class="'</span>+param.className+<span class="string">' js-mh-xChart'</span>+i+<span class="string">'"&gt;'</span>+param.val+param.unit+<span class="string">'&lt;/span&gt;'</span>);
            <span class="comment">/*计算当前值与最小值的差值映射在坐标图中当前点距离最左边点的距离*/</span>
            <span class="keyword">var</span> left = <span class="built_in">parseInt</span>(((param.val - param.minVal) * mapWidth /(param.maxVal - param.minVal)) - $(<span class="string">'.js-mh-xChart'</span>+i).width()/<span class="number">2</span>);
            $(<span class="string">'.js-mh-xChart'</span>+i)[<span class="number">0</span>].style.left=left+<span class="string">"px"</span>;
            Carr.push(param.val);
            param.val += param.spacing;
        }
        <span class="comment">/*生成最后一个点*/</span>
        $(param.parentNode,chart).append(<span class="string">'&lt;span class="'</span>+param.className+<span class="string">' js-mh-xChart'</span>+i+<span class="string">'"&gt;'</span>+param.maxVal+param.unit+<span class="string">'&lt;/span&gt;'</span>);
        <span class="keyword">var</span> left = <span class="built_in">parseInt</span>(((param.maxVal - param.minVal) * mapWidth /(param.maxVal - param.minVal)) - $(<span class="string">'.js-mh-xChart'</span>+i).width()/<span class="number">2</span>);
        $(<span class="string">'.js-mh-xChart'</span>+i)[<span class="number">0</span>].style.left=left+<span class="string">"px"</span>;
    }<span class="keyword">else</span>{
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){
            <span class="keyword">var</span> valY = dataYround(param.val);
            $(param.parentNode,chart).prepend(<span class="string">'&lt;p class='</span>+param.className+<span class="string">'&gt;'</span>+valY.y+valY.unit+param.unit+<span class="string">'&lt;/p&gt;'</span>);
            Carr.push(param.val);
            param.val += +param.spacing;
            param.val = +(param.val).toFixed(<span class="number">2</span>);
        }
        <span class="comment">/*生成最后一个点*/</span>
        <span class="keyword">var</span> valY = dataYround(param.maxVal);
        $(param.parentNode,chart).prepend(<span class="string">'&lt;p class='</span>+param.className+<span class="string">'&gt;'</span>+valY.y+valY.unit+param.unit+<span class="string">'&lt;/p&gt;'</span>);
    }
    Carr.push(param.maxVal);
    <span class="keyword">return</span> Carr;
}   
</code></pre><p>解释一下几个具体的点：isX为true为x轴处理逻辑，false为y轴处理逻辑。for循环将所有的点渲染出来，最后将最后一个点的位置单独绘制出来，单独绘制的原因之前说业务逻辑的时候有提到。这里需要强调一点，在x轴处理的时候需要一边渲染数据一边计算当前值与最小值得差值映射在坐标图中距离最左边点的距离，同时需要减去当前点的文案长度的1/2。<br>到目前为止横纵坐标已经处理完成了，现在要开始画折线图啦！canvas神奇闪亮登场！！欢呼欢呼！！我终于写完四分之一了！<img src="/img/pada1.gif" width="30" height="30" style="display: inline-block"><br>canvas绘制首先新建一个chart对象。具体结构如下：</p>
<pre><code><span class="comment">/*绘制表格*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">Chart</span><span class="params">( config )</span></span>{
    <span class="keyword">var</span> _this = <span class="keyword">this</span>;
    _this.ele = {

    };
    _this.data = {

    };
}
</code></pre><p>以上是画图所需要的所有参数的，现在我们基于这些定义好的参数开始绘制折线图。<br>首先需要initCanvas画布</p>
<pre><code>initCanvas : <span class="function"><span class="keyword">function</span>(<span class="params">className</span>)</span>{
            <span class="keyword">var</span> _this = <span class="keyword">this</span>;
            <span class="keyword">var</span> canvasEle = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);
            <span class="keyword">var</span> width = +_this.data.chartWidth;
            <span class="keyword">var</span> height = +_this.data.chartHeight;
            $(canvasEle).width(width)
                        .height(height)
                        .attr(<span class="string">'width'</span>,width)
                        .attr(<span class="string">'height'</span>,height)
                        .addClass(className);
            <span class="comment">/*针对IE8以下低版本浏览器的处理*/</span>
            <span class="keyword">if</span>(_this.data.IE8_AND_LOWER){
                canvasEle=<span class="built_in">window</span>.G_vmlCanvasManager.initElement(canvasEle);
            }
            _this.ele.canvasWrap.append(canvasEle);
        }
</code></pre><p>传入包裹canvas的外层容器，动态创建canvas元素，并为canvas元素复制高度和宽度，这里需要注意的一点是：细心的你有么有发现我们在attr和style里面分别定义了两次宽度和高度，这个其实就是为了兼容retina屏幕2倍尺寸做的处理，style中的width和height是我们初始化时候的值，当你的屏幕是retina屏的时候，attr中的width和height就会处理成乘以2的值。if判断中对IE8以下的浏览器，无法获取getContext的方法，采用<a href="https://github.com/yinso/excanvas" target="_blank">excanvas</a>这个插件来兼容。<br>然后开始画背景</p>
<pre><code>drawChart: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">var</span> _this = <span class="keyword">this</span>;
            <span class="keyword">var</span> chartCtx = _this.ele.canvasChart.getContext(<span class="string">'2d'</span>);
            <span class="comment">/*中心平移，防止边缘反锯齿*/</span>
            chartCtx.translate(<span class="number">0.5</span>, <span class="number">0.5</span>);
            <span class="comment">/*画背景网格*/</span>
            _this.drawBackground(chartCtx);
            <span class="comment">/*画数据*/</span>
            _this.drawLine(chartCtx);
        }
drawBackground: <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>{
            <span class="keyword">var</span> _this = <span class="keyword">this</span>;
            ctx.beginPath();
            ctx.strokeStyle = <span class="string">'#dcdcdc'</span>;
            ctx.lineWidth = <span class="number">1.0</span>;
            <span class="keyword">var</span> lineSpace = _this.data.lineSpace;
            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;_this.data.lineNum;i++){
                <span class="keyword">var</span> lineY = <span class="built_in">parseInt</span>(i * lineSpace);
                ctx.moveTo(<span class="number">0</span>,lineY+_this.data.tOffset);
                ctx.lineTo(_this.data.chartWidth, lineY+_this.data.tOffset);
            }
            ctx.stroke();
        }
</code></pre><p>lineNum为背景线的总个数，定义背景线的颜色，宽度，两线间隔，起点是（0，lineY+_this.data.tOffset）lineY为通过根据两线间的间隔计算的值，tOffset为距离顶部的位移量，终点是（_this.data.chartWidth, lineY+_this.data.tOffset）_this.data.chartWidth表示图表的宽度。效果图:<img src="/img/chart5.png" alt="" width="400" height="200">。<br>这里需要强调一下，<em>chartCtx.translate(0.5, 0.5);</em>这里的用意，是因为在绘制宽度为1的线条时，canvas是以线条宽度中间位置作为渲染中心像上下方向晕染，所以为了清晰成像，我们将画布平移二分之一宽度。<br>现在可以在这个背景的上面绘制折现图了，需要声明的是在绘制折线图之前，需要对数据处理，此处细节忽略一万字……<br>假如我们的数据已经处理好了哦，现在开始画图</p>
<pre><code>drawLine: <span class="keyword">function</span>(ctx){
            <span class="comment">/*绘制折线图*/</span>
            var <span class="number">_</span><span class="keyword">this</span> = <span class="keyword">this</span>;
            <span class="comment">/*getposition方法为忽略一万字的逻辑*/</span>
            <span class="number">_</span><span class="keyword">this</span>.getPosition(<span class="number">_</span><span class="keyword">this</span>.data.points);
            ctx.strokeStyle = <span class="string">'#19b955'</span>;
            ctx.fillStyle = <span class="string">'#19b955'</span>;
            ctx.lineWidth = <span class="number">2.0</span>;
            ctx.beginPath();
            <span class="keyword">for</span>(var i=<span class="number">0</span>; i&lt;<span class="number">_</span><span class="keyword">this</span>.data.pointsPosition.length;i++){
                <span class="keyword">if</span>(i + <span class="number">1</span> === <span class="number">_</span><span class="keyword">this</span>.data.pointsPosition.length){
                    <span class="keyword">break</span>;
                }
                ctx.moveTo(<span class="number">_</span><span class="keyword">this</span>.data.pointsPosition[i][<span class="number">0</span>],<span class="number">_</span><span class="keyword">this</span>.data.pointsPosition[i][<span class="number">1</span>]);
                ctx.lineTo(<span class="number">_</span><span class="keyword">this</span>.data.pointsPosition[i+<span class="number">1</span>][<span class="number">0</span>],<span class="number">_</span><span class="keyword">this</span>.data.pointsPosition[i+<span class="number">1</span>][<span class="number">1</span>])
            }
            ctx.stroke();
        }
</code></pre><p>其实做法和画背景图的线差不多，_ this.data.pointsPosition.length表示的是要绘制的点的长度，确定好折线图的颜色和宽度，将整个折线图分割成为若干个小线段，每个小线段的起点是当前点，终点是下一个点。<br>这时候折线图就画好了，看看效果：<br><img src="/img/chart6.png" alt="" width="400" height="200"><br>现在到最后一步了，我们来绘制hover效果。处理思路就是：你需要获取当前鼠标hover在canvas中的x轴的位置，然后根据hover点的x坐标获取对应点的实际数据，同时利用当前的x坐标画出hover的虚线，再利用对应的实际数据画出hover的圆点。</p>
<pre><code><span class="comment">/*画鼠标hover圆点以及竖线*/</span>
drawArcPoint: <span class="keyword">function</span>(ctx,pointData){
        var <span class="number">_</span><span class="keyword">this</span> = <span class="keyword">this</span>;
        <span class="comment">/*画出横坐标的动态值*/</span>
        <span class="number">_</span><span class="keyword">this</span>.ele.tipsTextWrap.text(pointData.x);
        <span class="number">_</span><span class="keyword">this</span>.ele.tipsTextWrap[<span class="number">0</span>].style.left = <span class="number">_</span><span class="keyword">this</span>.data.arcPos.x - <span class="number">_</span><span class="keyword">this</span>.ele.tipsTextWrap.width()/<span class="number">2</span> +<span class="string">'px'</span>;
        <span class="comment">/*这里要实时跟踪鼠标位置，所以在重新绘制之前应该清除之前绘制的圆点和竖线*/</span>
        ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">_</span><span class="keyword">this</span>.data.chartWidth,<span class="number">_</span><span class="keyword">this</span>.data.chartHeight);
        <span class="comment">/*开始绘制*/</span>
        ctx.beginPath();
        <span class="comment">/*定义线的颜色*/</span>
        ctx.strokeStyle = <span class="string">'#dcdcdc'</span>;
        <span class="comment">/*定义线的宽度*/</span>
        ctx.lineWidth = <span class="number">1.0</span>;
        <span class="comment">/*起始点*/</span>
        ctx.moveTo(<span class="number">_</span><span class="keyword">this</span>.data.arcPos.x,<span class="number">0</span>);
        <span class="comment">/*终点*/</span>
        ctx.lineTo(<span class="number">_</span><span class="keyword">this</span>.data.arcPos.x,<span class="number">_</span><span class="keyword">this</span>.data.mapHeight + <span class="number">_</span><span class="keyword">this</span>.data.tOffset);
        ctx.stroke();
        <span class="keyword">if</span>(pointData.y !== undefined){
            <span class="comment">/*绘制圆点*/</span>
            ctx.beginPath();
            ctx.arc(<span class="number">_</span><span class="keyword">this</span>.data.arcPos.x,<span class="number">_</span><span class="keyword">this</span>.data.arcPos.y,<span class="number">4.5</span>,<span class="number">0</span>,Math.PI*<span class="number">2</span>,true);
            ctx.fillStyle = <span class="string">"#19b955"</span>;
            ctx.fill();
        }
    }
</code></pre><p>当然还处理一下边界的问题，这里就不讲这个细节了~至此折线图就画完了，以上讲述的都是整个代码中的部分关键点，还有一些具体的操作并没有详细来讲，我写了两个小demo（<a href="/demo/chart.html" target="_blank">pc端</a>，<a href="/demo/m-chart.html" target="_blank">移动端</a>），包含移动和PC两部分，如果你感情去的话可以下载源码自己试试哈~<br>恩，现在我们来说说，对retina屏幕的兼容问题，像你了解的那样，retina是DPR=2[DPR(devicePixelRatio) = 设备像素 / CSS像素],来看下面这个图：<img src="/img/chart7.png" width="400" height="200" alt="">,所以正常绘制的话，就会导致retina屏幕呈现的效果有些模糊，所以我们用了一个兼容的插件<a href="https://github.com/jondavidjohn/hidpi-canvas-polyfill" target="_blank">hidpi-canvas-polyfill</a>处理原理呢就是：获取window.devicePixelRatio的值，将canvas所用到的绘制数据都乘以对应的DPR的值，然后就可以清晰地成像了。<br>最后的最后，来介绍一下IE8以下老版本浏览器兼容canvas神器，前面提到过得excanvas.js,使用方式：</p>
<pre><code>canvasEle=<span class="built_in">window</span>.G_vmlCanvasManager.initElement(canvasEle);
</code></pre><p>原理是由于老版本浏览器无法获取getContext的方法，通常情况下，脚本会报错，而excanvas完美的将canvas转换成为IE喜欢的VML(Vector Markup Language)格式进行绘制。<br>好了，写完了，累shi宝宝了……<img src="/img/pada3.gif" width="30" height="30" style="display: inline-block"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-HTTP解读（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/05/HTTP解读（二）/" class="article-date">
  	<time datetime="2016-02-05T03:07:42.000Z" itemprop="datePublished">2016-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/05/HTTP解读（二）/">HTTP解读（二）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章我们来结合上一篇<a href="http://imwineki.cn/2016/01/25/HTTP%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/">HTTP解读（一）</a>唆唆HTTP中一些基本的概念，主要也是我想归纳一下一些基本的知识点。<br>上篇中提到了客户端发送了一条请求后是经历了怎样的层层关卡才到达了服务器，我们这里就每一层的细节展开分析。<br>HTTP报文是简单的格式化数据块，分为：请求报文和响应报文，由三部分组成：起始行（start line）  首部（header）  主体（body）<br>报文包含：方法（method）请求URL（request-URL）版本（version）状态码（status-code）原因状态（reason-phrase）首部（header）实体的主体部分（entity-body）<br>一。起始行（所有HTTP报文都包含起始行）：包含请求行和响应行两部分<br>1.请求行</p>
<ul>
<li>请求报文的起始行说明要做什么，响应报文的起始行说明发生了什么。</li>
<li>包含：一个方法+一个请求URL</li>
<li>方法描述服务器应该执行的操作，请求URL描述对哪个资源执行这个方法</li>
<li>请求行中包含HTTP版本，告诉服务器使用哪个HTTP方案</li>
</ul>
<p>2.响应行</p>
<ul>
<li>包含响应报文HTTP版本，数字状态码，描述操作状态的文本形式的原因短语</li>
</ul>
<p>3.方法<br>总体来说，客户端向服务器发送请求无外乎以下几种标准方法（注意这里只是说标准方法，包含不仅限于这几种，有的服务器还是实现了自己特有的HTTP的方法，称为扩展方法）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否包含主体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">从服务器获取一份文档</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">只从服务器获取响应报文的头部</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">向服务器发送需要处理的数据</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">将请求的主体部分存储在服务器上</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">TRACE</td>
<td style="text-align:center">对可能经过代理服务器传送到服务器上的报文进行追踪</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:center">决定在服务器上可以执行哪些方法</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">从服务器上删除一份文档</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>4.状态码<br>方法是用来告诉服务器做什么事情，状态码是用来告诉客户端发生了什么事情，状体码分为以下几类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">整体范围</th>
<th style="text-align:center">已定义范围</th>
<th style="text-align:center">分类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100~199</td>
<td style="text-align:center">100~101</td>
<td style="text-align:center">信息提示</td>
</tr>
<tr>
<td style="text-align:center">200~299</td>
<td style="text-align:center">200~206</td>
<td style="text-align:center">成功</td>
</tr>
<tr>
<td style="text-align:center">300~399</td>
<td style="text-align:center">300~305</td>
<td style="text-align:center">重定向</td>
</tr>
<tr>
<td style="text-align:center">400~499</td>
<td style="text-align:center">400~415</td>
<td style="text-align:center">客户端错误</td>
</tr>
<tr>
<td style="text-align:center">500~599</td>
<td style="text-align:center">500~505</td>
<td style="text-align:center">服务器错误</td>
</tr>
</tbody>
</table>
<p>常见的状态码：<br>200 状态短语：OK 成功，401 状态短语：Unauthorized(未授权) 需要输入用户名和密码，404 状态短语：Not Found 未找到，502 状态短语：Bad Category 网关错误</p>
<p>5.原因短语</p>
<p>6.版本号<br>HTTP/x.y形式出现<br>二。首部：包含通用首部，请求首部，响应首部，实体首部，扩展首部<br>常见首部：如图<img src="/img/http2-1.png" alt=""><br>通用首部中还包含通用缓存首部，请求首部中包含Accept首部，条件请求首部，安全请求首部，代理请求首部。<br>响应首部中包含协商首部，安全响应首部。<br>实体首部中包含内容首部，实体缓存首部。<br>三。主体：HTTP报文实体主体部分是可选的<br>说了这么多是不是很不直观？没关系，来举个🌰就直观了。比如：我现在在浏览器地址栏中输入了：http:www.imwineki.cn/index.html，当我按下回车后的下一秒，浏览器就向服务器发送了一条get请求，请求的文档的当然就是index.html这个文件了，当然服务器会将文件找到后返回回来，酱紫你就能看到我的博客的主页了（通常相应的状态是200）。这张图就是我发送请求是的截图，我们来分析一下：<img src="/img/http2-2.png" alt=""><br>起始行信息：<br>Request Url跳转链接，Request Method请求方法为get方法，Remote status相应状态码200 ok，Remote Address请求IP地址（默认80端口）<br>首部：Request Header<br>    通用首部：Date:Fri, 05 Feb 2016 10:44:59 GMT<br>            Connection:keep-alive<br>            Via:1.1 varnish<br>    通用缓存首部：Cache-Control:max-age=600<br>    请求首部：Accept-Ranges:bytes<br>            Host:imwineki.cn<br>            User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.103 Safari/537.36<br>    响应首部：Server:GitHub.com<br>    实体首部：Content-Encoding:gzip<br>            Content-Length:4838<br>            Content-Type:text/html; charset=utf-8<br>差不多就这些了，写的好辛苦@……@！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-HTTP解读（一）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/25/HTTP解读（一）/" class="article-date">
  	<time datetime="2016-01-25T15:00:38.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/HTTP解读（一）/">HTTP解读（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近一直在学习HTTP相关知识，学到的知识总是要总结一下嘛，分几篇文章总结粗来~<br>这篇主要内容关于Web基础相关的，知识点都比较浅显易懂，恩，闲话就说到这里。<br>HTTP是因特网的传输媒介，是应用层协议，它把联网细节都交给了通用可靠的因特网传输协议：TCP/IP。大概的关系如图:<img src="/img/http2.png" alt="">当客户端与服务器沟通的时候就需要HTTP作为信使来传递消息，通常情况下，客户端会给服务器发送一条HTTP请求，请求需要的文档，服务器收到请求后经过处理就会给客户端做出一个响应，告诉客户端处理结果。当然这里我们说的客户端其实就是我们熟悉的浏览器。举个栗子🌰，当你在浏览器里输入<a href="http://imwineki.cn/index.html">http://imwineki.cn/index.html</a>,然后按下回车键后，简单来说，就会发生以下这一些列的事情，如图，<br><img src="/img/http1.png" alt="">浏览器就会向服务器www.imwineki.cn发送一条HTTP请求，此时服务器收到请求后，就会去寻找index.html的文档，找到了的话就会返回给浏览器文档信息。以及一个200的状态码，如果失败的话就会根据具体的错误情况返回具体的错误状态。<br>稍微复杂一点来说，当你按下回车后，http会解析URL的语法，通常包含：以下几种：<br><img src="/img/http3.png" alt="">，获取到<http:imwineki.cn index.html="">使用的是http协议，同过DNS查询主机，获取到该域名下对应的服务器的IP地址，以及端口号（默认情况下是80端口），获取到服务器的IP地址后，此时如果我土豪的买了CDN服务的话，接下来代理就会将请求发送给缓存（CDN），缓存根据文件副本的新鲜度来决定返回客户端数据还是向原始服务器发出请求,如果代理需要向服务器发请求，则CDN充当客户端的角色会向服务器发送请求（具体请求头部等这里先不介绍），当请求到达服务器后，则首先到达反向代理服务器，如果反向代理中包含文件副本则直接返回，否则反向代理再次向服务器或服务器集群转发请求，如图<img src="/img/http4.png" alt="">。当然我说的这些流程都是小型网站，至于大型网站架构，中间还要包含LVS负载均衡，虚拟IP等加速工具。这里需要说明的一点：反向代理和CDN都属于缓存，都是为了减少服务器压力，降低用户等待时间，加速网站相应的，所不同的是：CDN部署在网络提供商的机房，在用户发出请求后，可以优先从距离最近的网络提供商机房获取数据，但反向代理则是部署在中心机房，当请求到来时，会优先走反向代理。</http:imwineki.cn></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-web传输/">HTTP web传输</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Thinkjs实现异步加载模板方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/14/Thinkjs实现异步加载模板方法/" class="article-date">
  	<time datetime="2015-12-14T09:23:10.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/Thinkjs实现异步加载模板方法/">Thinkjs实现异步加载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天来总结一下关于使用Thinkjs来实现页面异步加载的原理和做法。<br>我从前端讲起，首先流程中包含一下几部分：</p>
<table>
<thead>
<tr>
<th>View</th>
<th style="text-align:center">Controller</th>
<th style="text-align:right">Model</th>
</tr>
</thead>
<tbody>
<tr>
<td>筛选框（filter）用于筛选内容，位置在母模版</td>
<td style="text-align:center">母模版对应的Action</td>
<td style="text-align:right">调用数据库</td>
</tr>
<tr>
<td>异步加载内容（content），位置在子模板</td>
<td style="text-align:center">ajax判断后的处理</td>
<td style="text-align:right">调用数据库</td>
</tr>
</tbody>
</table>
<p>下面根据代码具体解释一下：<br>母模版的view层demo：</p>
<pre><code><span class="xml">/*这里是一个filter*/
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"filter"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dl</span> <span class="attribute">class</span>=<span class="value">"row"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dt</span>&gt;</span>大小<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
        <span class="tag">&lt;<span class="title">dd</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>全部<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>大<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>中<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>小<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">dl</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
/*这里是一个content*/
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span>&gt;</span>
    </span>&lt;%<span class="ruby"><span class="keyword">include</span> ajax/tplselectajax.html</span>%&gt;<span class="xml">     /*这里include进来一个子模板，将来异步刷新时就只刷新子模板数据*/
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span>
</code></pre><p>子模板的view层demo:<br>    可以看到从后端传来一个tpllist的数据字段，相当于是一个数组，我们把它循环输出出来，同时一会异步刷新的时候我们也只是刷新这个子模板的数据，而不会改变上面的母模板的数据。</p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"cont-wrap"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
        </span><span class="vbscript">&lt;%tpllist.forEach(<span class="keyword">function</span>(item){ %&gt;</span><span class="xml">
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="vbscript">&lt;%=item.desc%&gt;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
                <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="vbscript">&lt;%=item.name%&gt;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        </span><span class="vbscript">&lt;%})%&gt;</span><span class="xml">
    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span>
</code></pre><p>当然这里需要js来帮忙使用ajax来进行一步调用:</p>
<pre><code>$(<span class="string">'a'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{
    e.preventDefault();
    $.ajax({
        url:<span class="string">''</span>,<span class="comment">/*填写请求路径*/</span>
        dataTpe:<span class="string">'jsonp'</span>,
        data:<span class="string">''</span>,<span class="comment">/*传送的数据*/</span>
        success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{

        },
        fail:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{

        }

    });
});
</code></pre><p>Controller层的处理:</p>
<pre><code>tplselectAction: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> <span class="keyword">self</span> = this;
    <span class="comment">/*获取get请求的参数，在这个demo中其实就是筛选条件*/</span>
    <span class="keyword">var</span> data = this.get();  
    <span class="keyword">var</span> pg = data.pg;
    <span class="comment">/*判断时候是ajax请求，如果是则结果返回true*/</span>
    <span class="keyword">var</span> isAjax = <span class="keyword">self</span>.isAjax();   
    <span class="comment">/*子模板渲染路径，注意此处根目录是Home*/</span>
    <span class="keyword">var</span> tpl = <span class="string">'Home/ajax/build_tplselectajax.html'</span>;         
    <span class="keyword">if</span>(!isAjax){
        <span class="comment">/*如果不是ajax请求，也就是浏览器首次渲染数据时，默认选择展示全部数据*/</span>
        data = { cateId: <span class="string">'全部'</span>}
    }
    <span class="comment">/*调用数据库获取数据，调用ajaxdata方法*/</span>
    D(<span class="string">'Template'</span>).ajaxdata(data,pg).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
        <span class="keyword">var</span> <span class="keyword">list</span> = shiftObject(data,<span class="string">'data'</span>);  <span class="comment">/*将数据库data字段整体存入list*/</span>
        <span class="keyword">self</span>.assign(<span class="string">'tpllist'</span>,<span class="keyword">list</span>);  
        <span class="keyword">self</span>.assign(<span class="string">'isAjax'</span>,isAjax);
        <span class="keyword">if</span>(isAjax){
            <span class="comment">/*如果是ajax模板，则利用fetch这个方法对模板进行重新渲染，并返回相应json格式的状态值*/</span>
            <span class="keyword">if</span>(<span class="keyword">list</span>.length !== <span class="number">0</span>){
                <span class="keyword">self</span>.fetch(tpl).then(<span class="function"><span class="keyword">function</span><span class="params">(content)</span></span>{
                   <span class="keyword">self</span>.jsonp({status:<span class="string">"success"</span>,cont:content});
                });
            }<span class="keyword">else</span>{
                <span class="keyword">self</span>.jsonp({status:<span class="string">"fail"</span>,cont:<span class="string">'暂时木有相应的模板，搜搜别的试试吧！'</span>});
            }
        }<span class="keyword">else</span>{
            <span class="comment">/*首次加载页面则直接展示*/</span>
            <span class="keyword">self</span>.display();
        }
    });
}
</code></pre><p>Model层的处理demo：</p>
<pre><code>ajaxdata: function(<span class="built_in">data</span>){
    <span class="built_in">var</span> <span class="built_in">self</span> = this;
    <span class="keyword">if</span>(<span class="built_in">data</span><span class="built_in">.</span>cateId = <span class="string">'全部'</span>){
        <span class="keyword">return</span> <span class="built_in">self</span><span class="built_in">.</span><span class="keyword">order</span>({<span class="string">'id'</span>:<span class="string">'desc'</span>})<span class="built_in">.</span><span class="keyword">select</span>()<span class="built_in">.</span>then(function(<span class="built_in">data</span>){
            <span class="keyword">return</span> <span class="built_in">data</span>;
        });
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> <span class="built_in">self</span><span class="built_in">.</span><span class="keyword">where</span>({<span class="string">'title'</span>:<span class="built_in">data</span><span class="built_in">.</span>cateId})<span class="built_in">.</span><span class="keyword">order</span>({<span class="string">'id'</span>:<span class="string">'desc'</span>})<span class="built_in">.</span><span class="keyword">select</span>()<span class="built_in">.</span>then(function(<span class="built_in">data</span>){
            <span class="keyword">return</span> <span class="built_in">data</span>;    
        });
    }
}
</code></pre><p>Model层的处理：<br>这里是项目源代码的查询:</p>
<pre><code>ajaxdata: <span class="function"><span class="keyword">function</span><span class="params">(data,pg)</span></span>{
        var self = this;
        var <span class="keyword">where</span> = <span class="keyword">where</span> || {};
        /*此处包含其他参数的复合查询，展示出来，在demo中暂时不考虑*/
        /*var join = {
            templatecate: {
                join: <span class="string">'left'</span>,
                as: <span class="string">'c'</span>,
                on: [<span class="string">'cateId'</span>,<span class="string">'id'</span>]
            }
        };
        var pg = pg || (isNumber(<span class="keyword">where</span>) ? <span class="keyword">where</span> : null);
        var lastCond = {};
        <span class="keyword">if</span>(<span class="comment">!isEmpty(where)){</span>
            for(var i <span class="type">in</span> <span class="keyword">where</span>){
                var find = false;
                for(var s <span class="type">in</span> fields){
                    <span class="keyword">if</span>(fields[s].indexOf(i) &gt; -<span class="number">1</span>){
                        lastCond[s + <span class="string">'.'</span> + i] = <span class="keyword">where</span>[i];
                        find = true;
                        break;
                    }
                }
                <span class="keyword">if</span>(find)<span class="keyword">continue</span>;
                lastCond[<span class="string">'t.'</span> + i] = <span class="keyword">where</span>[i];
            }
        }*/
        <span class="keyword">if</span>(<span class="type">data</span>.cateId == <span class="string">'全部'</span>){
            var per = C(<span class="string">'db_nums_per_page'</span>);
            /*在筛选框为‘全部’时，将数据中全部数据按条件查询出来，并且进行分页查询（分页查询此处我们暂时不讨论）*/
            <span class="keyword">return</span> self.<span class="keyword">where</span>({<span class="string">'endType'</span>:<span class="type">data</span>.<span class="keyword">endType</span>,<span class="string">'isForbidden'</span>:<span class="number">0</span>}).order({<span class="string">'id'</span>: <span class="string">'desc'</span>}).page(pg).<span class="keyword">select</span>().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
                    <span class="keyword">return</span> <span class="type">data</span>;
            }).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(datalist)</span></span>{
                /*将返回结果进行处理，并返回相应的参数*/
                <span class="keyword">return</span> self.field(<span class="string">'count(id) as count'</span>).<span class="keyword">where</span>({<span class="string">'endType'</span>:<span class="type">data</span>.<span class="keyword">endType</span>}).find().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>{
                    <span class="keyword">return</span> {
                        <span class="type">data</span>: datalist,
                        <span class="built_in">count</span>: res.<span class="built_in">count</span>,
                        page: pg || <span class="number">1</span>,
                        num: per,
                        total: Math.ceil(res.<span class="built_in">count</span> / per)
                    };
                });
            }); 
        }<span class="keyword">else</span>{
            /ajax请求是查询结果，按照cateId的值进行查询/
            var per = C(<span class="string">'db_nums_per_page'</span>);
            <span class="keyword">return</span> self.alias(<span class="string">'t'</span>).field(<span class="string">'t.*'</span>).join(join).<span class="keyword">where</span>({<span class="string">'c.title'</span>:<span class="type">data</span>.cateId,<span class="string">'t.endType'</span>:<span class="type">data</span>.<span class="keyword">endType</span>,<span class="string">'isForbidden'</span>:<span class="number">0</span>}).order({<span class="string">'t.id'</span>: <span class="string">'desc'</span>}).page(pg).<span class="keyword">select</span>().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
                    <span class="keyword">return</span> <span class="type">data</span>;
            }).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(datalist)</span></span>{
                <span class="keyword">return</span> self.alias(<span class="string">'t'</span>).field(<span class="string">'count(t.id) as count'</span>).join(join).<span class="keyword">where</span>({<span class="string">'c.title'</span>:<span class="type">data</span>.cateId,<span class="string">'t.endType'</span>:<span class="type">data</span>.<span class="keyword">endType</span>}).find().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>{
                    <span class="keyword">return</span> {
                        <span class="type">data</span>: datalist,
                        <span class="built_in">count</span>: res.<span class="built_in">count</span>,
                        page: pg || <span class="number">1</span>,
                        num: per,
                        total: Math.ceil(res.<span class="built_in">count</span> / per)
                    };
                });
            }); 
        }

    }
</code></pre><p>关于Thinkjs里面的具体语法我就不一一解释了，这里主要来讲一下大概的思路，首先前端需要在模板中将需要异步加载的模板进行include,方便后续的异步刷洗页面，同时你需要用js来进行一个ajax的通信，接着就是Controller层对模板的渲染，在拿到前端传来的请求数据后，调用model层的方法从数据库中取出数据，此时需要使用feteh这个方法重新渲染页面。（其实也可以使用display(渲染模板路径)这个方法，只是渲染的方式不用而已，结果是一样的）感兴趣的同学可以搜一下API。<br>sql语句写的不好，还望大家见谅~~哈哈哈，先就这么多~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-css选择器优先级权重分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/25/css选择器优先级权重分析/" class="article-date">
  	<time datetime="2015-11-25T15:25:41.000Z" itemprop="datePublished">2015-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/25/css选择器优先级权重分析/">css选择器优先级权重分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近写项目发现了css的一些小问题总结出来，主要是关于css选择器权重相关的。<br>在浏览器中，我们在编写页面样式的时候通常都要考虑选择器的优先级，使得页面的样式不会被覆盖或覆盖其他样式。<br>总体来说优先级是这样的（此处从高到底排序）：</p>
<blockquote>
<p>!important  -&gt;   行内样式style(此处包含写在html结构中的和用js动态加载上去的style)  -&gt;  id选择器  -&gt;  伪类  -&gt;  class选择器  -&gt;  元素选择器  -&gt;  通用选择器( * )</p>
</blockquote>
<p>这里我来对一些细节说明一下：<br>1.页面中能不要使用！important尽量避免使用，因为从严格意义上讲，！important与优先级是没有关系的，当使用!important定义模块的时候页面中再对其进行任何操作都无济于事了，改变了样式表本来的级联规则，难以调试。<br>2.行内样式这里的两方面距离说明：</p>
<pre><code><span class="number">1</span>.&lt;<span class="tag">p</span> style=<span class="string">"color:red"</span> id=<span class="string">"test"</span>&gt;&lt;/p&gt;

<span class="number">2</span>. document.<span class="function"><span class="title">getElementById</span><span class="params">(<span class="string">'topnav'</span>)</span></span><span class="class">.style</span><span class="class">.color</span> = <span class="string">'red'</span>
</code></pre><p>3.关于伪类的优先级遵循：LVHA,从右向左优先级逐级增加.然而not作为伪类，却并不列入伪类优先级的评比中，也就是说当元素有重新定义的样式的时候not会被自动覆盖。举例说明：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-not"</span>&gt;测试伪类<span class="keyword">not</span>&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"not"</span>&gt;<span class="number">123</span>&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>当定义样式为：</p>
<pre><code><span class="rule"><span class="attribute">.test-not</span>:<span class="value"><span class="function">not</span>(.not){
    color:red</span></span>;
}
</code></pre><p>效果如下图：<br><img src="/img/1.png" alt=""><br>123为黑色，说明样式中not生效了。<br>当定义样式为：</p>
<pre><code><span class="class">.not</span><span class="rules">{
    <span class="rule"><span class="attribute">color</span>:<span class="value">red</span></span>;
}</span>
<span class="rule"><span class="attribute">.test-not</span>:<span class="value"><span class="function">not</span>(.not){
    color:red</span></span>;
}
</code></pre><p>效果如下图：<br><img src="/img/2.png" alt=""><br>123显示为红色，说明not样式被元素本身定义的样式覆盖了。<br>4.关于a标签的说明：</p>
<pre><code>a:link{
    <span class="built_in">color</span>:<span class="built_in">green</span>;
}
<span class="comment">/*a:visited{
    color:yellow;
}*/</span>
.test{
    <span class="built_in">color</span>:<span class="built_in">red</span>;
}
&lt;a href=<span class="string">"/"</span> class=<span class="string">"test-relative"</span>&gt;相对目录&lt;/a&gt;
</code></pre><p>当我们把a标签加上link伪类的时候，link的优先级就高于class=”test”,所以在首次载入页面的时候文字会显示绿色，当我们点击链接后，发现文字又变回了红色，这是因为链接点击后的状态为visited，而在样式中我们将visited的样式定义注释掉了，所以链接样式就会直接显示class=”test”的样式了。<br>当我们将visited的样式定义去掉后，会发现颜色显示为黄色。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Thinkjs链式结构总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/25/Thinkjs链式结构总结/" class="article-date">
  	<time datetime="2015-11-25T15:12:59.000Z" itemprop="datePublished">2015-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/25/Thinkjs链式结构总结/">Thinkjs链式结构总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一篇博文，由于刚开始学习markdown的方式写博文，速度好慢。<br><br>最近在用<em>Thinkjs</em>写项目，又向从前端到全段的梦想迈进了一步，哈哈，写话少说，share一些干货粗来。<br><br><em>Thinkjs</em>是基于nodejs的web框架，具体的文档可以参看<a href="https://thinkjs.org/" target="_blank" rel="external">https://thinkjs.org/</a>官方文档，我使用的是1.0版本，所以暂时只讨论1.0的一些情况。<br>今天写项目中遇到这样一个问题：<br>我从session中获取到用户的信息，然后获取存在session中的userName，使用：</p>
<pre><code><span class="keyword">this</span>.session(<span class="string">"userInfo"</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
...
});
</code></pre><p>的方式，另一方面我通过数据库查询获取到用户在数据库中存储的userName,然后比较这两个userName时候否相同，使用</p>
<pre><code><span class="tag">D</span>(<span class="string">'User'</span>)<span class="class">.get</span>(id)<span class="class">.then</span>(<span class="function">function</span>(data){
...
}); 
</code></pre><p>再将一个标签值assign到view层对应的页面。<br>然而就在编写的过程中我发现我在比较之后，无法将标签值传入页面。<br>具体代码如图：<br><img src="http://p6.qhimg.com/d/inn/f451a883/code.png" alt="1"><br>这是一份伪代码，上面的图片的大概意思就是这样的：</p>
<pre><code><span class="keyword">return</span> D(<span class="string">'User'</span>).get(id).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
    <span class="keyword">return</span> <span class="keyword">self</span>.session(<span class="string">'user'</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(user)</span></span>{
        <span class="comment">//验证session信息,返回editable</span>
        <span class="keyword">self</span>.assign(<span class="string">'editable'</span>,editable);
        <span class="keyword">self</span>.assign(<span class="string">'user'</span>,data);
        <span class="keyword">self</span>.display();
    });
});
</code></pre><p>最初我是这么写的：</p>
<pre><code><span class="keyword">return</span> D(<span class="string">'User'</span>).get(id).then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>{
    <span class="keyword">var</span> session = <span class="keyword">self</span>.session(<span class="string">'user'</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(user)</span></span>{
        <span class="comment">//验证session信息,返回editable</span>
        <span class="keyword">self</span>.assign(<span class="string">'editable'</span>,editable);
    });
    <span class="keyword">self</span>.assign(<span class="string">'user'</span>,data);
    <span class="keyword">self</span>.display();
});
</code></pre><p>然后我发现这个根本没有想下执行，页面直接白屏了，原因其实是这样的，在<em>thinkjs</em>中绝大多数方法都是异步调用的，并且包装成promise，而promise是通过<br><em>try{}catch{}</em>进行异常捕获的，很显然我没有catch异常所以导致直接白屏，同时由于thinkjs中许多的调用都是异步调用（这个之前说过），也就是说在session还没有返回值的时候程序就向下执行了，但是此处我必须要它同步来执行，也就是说按照程序写的先后顺序来执行，所以就采用return的方法，将没有个异步方法串联起来，形成一个调用链就搞定了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Wineki
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>